# Release workflow for xcodex.
# To release, follow a workflow like:
# ```
# git tag -a xcodex-v0.1.0 -m "Release 0.1.0"
# git push origin xcodex-v0.1.0
# ```

name: xcodex-release
on:
  push:
    tags:
      - "xcodex-v*.*.*"
      - "xcodex-v*.*.*-alpha.*"

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

jobs:
  tag-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@1.92

      - name: Validate tag matches Cargo.toml version
        shell: bash
        run: |
          set -euo pipefail
          echo "::group::Tag validation"

          [[ "${GITHUB_REF_TYPE}" == "tag" ]] \
            || { echo "❌  Not a tag push"; exit 1; }
          [[ "${GITHUB_REF_NAME}" =~ ^xcodex-v[0-9]+\.[0-9]+\.[0-9]+(-alpha\.[0-9]+)?$ ]] \
            || { echo "❌  Tag '${GITHUB_REF_NAME}' doesn't match expected format"; exit 1; }

          tag_ver="${GITHUB_REF_NAME#xcodex-v}"
          cargo_ver="$(grep -m1 '^version' codex-rs/Cargo.toml \
                        | sed -E 's/version *= *\"([^\"]+)\".*/\1/')"

          [[ "${tag_ver}" == "${cargo_ver}" ]] \
            || { echo "❌  Tag ${tag_ver} ≠ Cargo.toml ${cargo_ver}"; exit 1; }

          # 4. Changelog should mention the version heading.
          if ! grep -q "^## ${tag_ver}$" CHANGELOG.md; then
            echo "❌  CHANGELOG.md missing heading: '## ${tag_ver}'"
            exit 1
          fi

          echo "✅  Tag and Cargo.toml agree (${tag_ver})"
          echo "::endgroup::"

      - name: Preflight native artifact targets
        shell: bash
        run: |
          set -euo pipefail

          python3 - <<'PY'
          from __future__ import annotations

          import ast
          import re
          from pathlib import Path

          repo_root = Path(".").resolve()
          installer_path = repo_root / "codex-cli" / "scripts" / "install_native_deps.py"
          workflow_path = repo_root / ".github" / "workflows" / "xcodex-release.yml"

          installer_src = installer_path.read_text(encoding="utf-8")
          mod = ast.parse(installer_src, filename=str(installer_path))

          binary_targets: list[str] | None = None
          for node in mod.body:
            if not isinstance(node, ast.Assign):
              continue
            for target in node.targets:
              if isinstance(target, ast.Name) and target.id == "BINARY_TARGETS":
                binary_targets = ast.literal_eval(node.value)
                break
            if binary_targets is not None:
              break

          if binary_targets is None:
            raise SystemExit(f"Could not find BINARY_TARGETS in {installer_path}")
          if not isinstance(binary_targets, tuple) or not all(isinstance(x, str) for x in binary_targets):
            raise SystemExit(f"Unexpected BINARY_TARGETS value in {installer_path}: {binary_targets!r}")

          workflow_src = workflow_path.read_text(encoding="utf-8").replace("\r\n", "\n").replace("\r", "\n")
          workflow_targets = set(
            re.findall(r"^[ \t]*target:\s*([A-Za-z0-9_-]+)", workflow_src, flags=re.MULTILINE)
          )

          expected = set(binary_targets)
          missing = sorted(expected - workflow_targets)
          extra = sorted(workflow_targets - expected)

          if missing or extra:
            lines = [
              "Native target mismatch between install_native_deps.py and workflow matrix.",
              f"Expected (from {installer_path}): {sorted(expected)}",
              f"Found (from {workflow_path}): {sorted(workflow_targets)}",
            ]
            if missing:
              lines.append(f"Missing targets in workflow: {missing}")
            if extra:
              lines.append(f"Extra targets in workflow: {extra}")
            raise SystemExit("\\n".join(lines))

          # Guardrail: ARM targets should run on ARM-capable runners to avoid cross-compile surprises.
          pairs = re.findall(
            r"^[ \t]*- runner:\s*([^\s]+)\s*\n[ \t]*target:\s*([^\s]+)",
            workflow_src,
            flags=re.MULTILINE,
          )
          pair_map = {(runner, target) for runner, target in pairs}
          required_pairs = {
            ("ubuntu-24.04-arm", "aarch64-unknown-linux-musl"),
            ("windows-11-arm", "aarch64-pc-windows-msvc"),
          }
          missing_pairs = sorted(required_pairs - pair_map)
          if missing_pairs:
            raise SystemExit(
              "ARM runner mapping mismatch; expected these (runner, target) pairs:\n"
              + "\n".join(f"- {runner} / {target}" for runner, target in missing_pairs)
            )

          print("✅ Native artifact target preflight passed.")
          PY

      - name: Verify config schema fixture
        shell: bash
        working-directory: codex-rs
        run: |
          set -euo pipefail
          echo "If this fails, run: just write-config-schema to overwrite fixture with intentional changes."
          cargo run -p codex-core --bin codex-write-config-schema
          git diff --exit-code core/config.schema.json

  build:
    needs: tag-check
    name: Build - ${{ matrix.runner }} - ${{ matrix.target }}
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 30
    permissions:
      contents: read
      id-token: write
    defaults:
      run:
        working-directory: codex-rs

    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: macos-latest
            target: aarch64-apple-darwin
          - runner: macos-latest
            target: x86_64-apple-darwin
          - runner: ubuntu-latest
            target: x86_64-unknown-linux-musl
          - runner: ubuntu-24.04-arm
            target: aarch64-unknown-linux-musl
          - runner: windows-latest
            target: x86_64-pc-windows-msvc
          - runner: windows-11-arm
            target: aarch64-pc-windows-msvc

    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@1.92
        with:
          targets: ${{ matrix.target }}
      - name: Ensure Rust target installed
        shell: bash
        run: rustup target add ${{ matrix.target }}

      - name: Setup Python (macOS)
        if: ${{ startsWith(matrix.runner, 'macos') }}
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Pin PyO3 interpreter (macOS)
        if: ${{ startsWith(matrix.runner, 'macos') }}
        shell: bash
        run: |
          set -euo pipefail
          python -V
          echo "PYO3_PYTHON=$(python -c 'import sys; print(sys.executable)')" >> "$GITHUB_ENV"

      - name: Install sccache
        uses: taiki-e/install-action@44c6d64aa62cd779e873306675c7a58e86d6d532 # v2
        with:
          tool: sccache@0.7.5

      - name: Configure sccache backend
        shell: bash
        run: |
          set -euo pipefail
          if [[ -n "${ACTIONS_CACHE_URL:-}" && -n "${ACTIONS_RUNTIME_TOKEN:-}" ]]; then
            echo "SCCACHE_GHA_ENABLED=true" >> "$GITHUB_ENV"
            echo "Using sccache GitHub backend"
          else
            echo "SCCACHE_GHA_ENABLED=false" >> "$GITHUB_ENV"
            echo "SCCACHE_DIR=${{ github.workspace }}/.sccache" >> "$GITHUB_ENV"
            echo "Using sccache local disk + actions/cache fallback"
          fi

      - name: Enable sccache wrapper
        shell: bash
        run: echo "RUSTC_WRAPPER=sccache" >> "$GITHUB_ENV"

      - name: Restore sccache cache (fallback)
        if: ${{ env.SCCACHE_GHA_ENABLED != 'true' }}
        uses: actions/cache/restore@v5
        with:
          path: ${{ github.workspace }}/.sccache/
          key: sccache-${{ matrix.runner }}-${{ matrix.target }}-${{ hashFiles('**/Cargo.lock') }}-${{ github.run_id }}
          restore-keys: |
            sccache-${{ matrix.runner }}-${{ matrix.target }}-${{ hashFiles('**/Cargo.lock') }}-
            sccache-${{ matrix.runner }}-${{ matrix.target }}-

      - uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            ${{ github.workspace }}/codex-rs/target/
          key: cargo-${{ matrix.runner }}-${{ matrix.target }}-release-${{ hashFiles('**/Cargo.lock') }}

      - name: Install cargo-chef
        if: ${{ !contains(matrix.target, 'pc-windows') }}
        uses: taiki-e/install-action@44c6d64aa62cd779e873306675c7a58e86d6d532 # v2
        with:
          tool: cargo-chef@0.1.71

      - name: Pre-warm dependency cache (cargo-chef)
        if: ${{ !contains(matrix.target, 'pc-windows') }}
        shell: bash
        run: |
          set -euo pipefail
          RECIPE="${RUNNER_TEMP}/chef-recipe.json"
          cargo chef prepare --recipe-path "$RECIPE"
          cargo chef cook --recipe-path "$RECIPE" --target ${{ matrix.target }} --release --all-features

      - if: ${{ contains(matrix.target, 'linux-musl') }}
        name: Install musl build tools
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools pkg-config

      - if: ${{ contains(matrix.target, 'linux-musl') }}
        name: Configure musl linker
        shell: bash
        run: |
          set -euo pipefail
          echo "CC=musl-gcc" >> "$GITHUB_ENV"
          echo "RUSTFLAGS=-C linker=musl-gcc" >> "$GITHUB_ENV"
          case "${{ matrix.target }}" in
            x86_64-unknown-linux-musl)
              echo "CARGO_TARGET_X86_64_UNKNOWN_LINUX_MUSL_LINKER=musl-gcc" >> "$GITHUB_ENV"
              ;;
            aarch64-unknown-linux-musl)
              echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=musl-gcc" >> "$GITHUB_ENV"
              ;;
          esac

      - name: Cargo build
        shell: bash
        run: |
          if [[ "${{ contains(matrix.target, 'pc-windows') }}" == 'true' ]]; then
            cargo build --target ${{ matrix.target }} --release --bin codex --bin codex-responses-api-proxy --bin codex-windows-sandbox-setup --bin codex-command-runner
          else
            cargo build --target ${{ matrix.target }} --release --bin codex --bin codex-responses-api-proxy
          fi

      - if: ${{ contains(matrix.target, 'pc-windows') }}
        name: Install zstd
        shell: powershell
        run: choco install -y zstandard

      - name: Stage artifacts
        shell: bash
        run: |
          dest="dist/${{ matrix.target }}"
          mkdir -p "$dest"
          target="${{ matrix.target }}"

          if [[ "${{ contains(matrix.target, 'pc-windows') }}" == 'true' ]]; then
            cp "target/${target}/release/codex.exe" "$dest/xcodex-${target}.exe"
            cp "target/${target}/release/codex-responses-api-proxy.exe" "$dest/xcodex-responses-api-proxy-${target}.exe"
            cp "target/${target}/release/codex-windows-sandbox-setup.exe" "$dest/codex-windows-sandbox-setup-${target}.exe"
            cp "target/${target}/release/codex-command-runner.exe" "$dest/codex-command-runner-${target}.exe"
          else
            cp "target/${target}/release/codex" "$dest/xcodex-${target}"
            cp "target/${target}/release/codex-responses-api-proxy" "$dest/xcodex-responses-api-proxy-${target}"
          fi

      - name: Compress artifacts
        shell: bash
        run: |
          dest="dist/${{ matrix.target }}"
          keep_originals=false
          if [[ "${{ contains(matrix.target, 'pc-windows') }}" == 'true' ]]; then
            keep_originals=true
          fi

          for f in "$dest"/*; do
            base="$(basename "$f")"

            if [[ "$base" == *.tar.gz || "$base" == *.zip || "$base" == *.dmg ]]; then
              continue
            fi

            tar -C "$dest" -czf "$dest/${base}.tar.gz" "$base"

            if [[ "${{ contains(matrix.target, 'pc-windows') }}" == 'true' ]]; then
              (cd "$dest" && 7z a "${base}.zip" "$base")
            fi

            zstd_args=(-T0 -19)
            if [[ "${keep_originals}" == false ]]; then
              zstd_args+=(--rm)
            fi
            zstd "${zstd_args[@]}" "$dest/$base"
          done

      - name: Save sccache cache (fallback)
        if: ${{ env.SCCACHE_GHA_ENABLED != 'true' }}
        uses: actions/cache/save@v5
        with:
          path: ${{ github.workspace }}/.sccache/
          key: sccache-${{ matrix.runner }}-${{ matrix.target }}-${{ hashFiles('**/Cargo.lock') }}-${{ github.run_id }}

      - name: sccache stats
        if: always()
        continue-on-error: true
        run: sccache --show-stats || true

      - uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.target }}
          path: |
            codex-rs/dist/${{ matrix.target }}/*

  stage:
    needs:
      - build
    name: stage
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    outputs:
      version: ${{ steps.release_name.outputs.name }}
      tag: ${{ github.ref_name }}
      should_publish_npm: ${{ steps.npm_publish_settings.outputs.should_publish }}
      npm_tag: ${{ steps.npm_publish_settings.outputs.npm_tag }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          path: dist

      - name: List
        run: ls -R dist/

      - name: Define release name
        id: release_name
        run: |
          version="${GITHUB_REF_NAME#xcodex-v}"
          echo "name=${version}" >> "$GITHUB_OUTPUT"

      - name: Determine npm publish settings
        id: npm_publish_settings
        env:
          VERSION: ${{ steps.release_name.outputs.name }}
        run: |
          set -euo pipefail
          version="${VERSION}"

          if [[ "${version}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "should_publish=true" >> "$GITHUB_OUTPUT"
            echo "npm_tag=" >> "$GITHUB_OUTPUT"
          elif [[ "${version}" =~ ^[0-9]+\.[0-9]+\.[0-9]+-alpha\.[0-9]+$ ]]; then
            echo "should_publish=true" >> "$GITHUB_OUTPUT"
            echo "npm_tag=alpha" >> "$GITHUB_OUTPUT"
          else
            echo "should_publish=false" >> "$GITHUB_OUTPUT"
            echo "npm_tag=" >> "$GITHUB_OUTPUT"
          fi

      - name: Setup Node.js for npm packaging
        uses: actions/setup-node@v4
        with:
          node-version: 22

      # install_native_deps.py uses the `dotslash` CLI to parse the rg manifest.
      - uses: facebook/install-dotslash@v2

      - name: Stage npm packages
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          ./scripts/stage_npm_packages.py \
            --release-version "${{ steps.release_name.outputs.name }}" \
            --package xcodex \
            --package xcodex-responses-api-proxy

      - name: Upload release payload
        uses: actions/upload-artifact@v4
        with:
          name: release-dist
          path: dist/**

  smoke-test-npm:
    needs: stage
    name: smoke-test-npm - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os:
          - ubuntu-latest
          - macos-latest
          - windows-latest

    steps:
      - uses: actions/download-artifact@v4
        with:
          name: release-dist
          path: dist

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install tarballs (local) + smoke test
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p smoke
          cd smoke

          npm init -y >/dev/null

          xcodex_tarball="$(ls ../dist/npm/xcodex-npm-*.tgz | head -n 1)"
          proxy_tarball="$(ls ../dist/npm/xcodex-responses-api-proxy-npm-*.tgz | head -n 1)"

          npm install "$xcodex_tarball" "$proxy_tarball"

          npx --no-install xcodex --version
          npx --no-install xcodex hooks init
          npx --no-install xcodex hooks test all --configured-only
          npx --no-install xcodex-responses-api-proxy --help

  create-release:
    needs:
      - stage
      - smoke-test-npm
    name: create-release
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: release-dist
          path: dist

      - name: Prepare GitHub Release notes
        shell: bash
        run: |
          set -euo pipefail
          version="${{ needs.stage.outputs.version }}"
          notes_src="docs/xcodex/releases/${version}.md"
          notes_out="dist/release-notes.md"

          if [[ -f "${notes_src}" ]]; then
            cp "${notes_src}" "${notes_out}"
          else
            printf '%s\n\n%s\n' \
              "# Release notes: xcodex v${version}" \
              "See \`codex-rs/common/src/whats_new.md\` and \`CHANGELOG.md\`." \
              >"${notes_out}"
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ needs.stage.outputs.version }}
          tag_name: ${{ needs.stage.outputs.tag }}
          body_path: dist/release-notes.md
          files: dist/**
          prerelease: ${{ contains(needs.stage.outputs.version, '-') }}

  publish-npm:
    if: ${{ needs.stage.outputs.should_publish_npm == 'true' }}
    name: publish-npm
    needs:
      - stage
      - create-release
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          registry-url: "https://registry.npmjs.org"
          scope: "@eriz1818"

      - name: Update npm
        run: npm install -g npm@latest

      - name: Download npm tarballs from release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          version="${{ needs.stage.outputs.version }}"
          tag="${{ needs.stage.outputs.tag }}"
          mkdir -p dist/npm

          gh release download "$tag" \
            --repo "${GITHUB_REPOSITORY}" \
            --pattern "xcodex-npm-${version}.tgz" \
            --dir dist/npm

          gh release download "$tag" \
            --repo "${GITHUB_REPOSITORY}" \
            --pattern "xcodex-responses-api-proxy-npm-${version}.tgz" \
            --dir dist/npm

      - name: Publish to npm
        env:
          VERSION: ${{ needs.stage.outputs.version }}
          NPM_TAG: ${{ needs.stage.outputs.npm_tag }}
        run: |
          set -euo pipefail
          tag_args=()
          if [[ -n "${NPM_TAG}" ]]; then
            tag_args+=(--tag "${NPM_TAG}")
          fi

          tarballs=(
            "xcodex-npm-${VERSION}.tgz"
            "xcodex-responses-api-proxy-npm-${VERSION}.tgz"
          )

          for tarball in "${tarballs[@]}"; do
            npm publish "${GITHUB_WORKSPACE}/dist/npm/${tarball}" --access public --provenance "${tag_args[@]}"
          done
