//! Generate Rust types for the in-repo `codex-hooks-sdk` crate.
//!
//! Usage:
//!   cd codex-rs
//!   cargo run -p codex-core --bin hooks_rust_sdk --features hooks-schema --quiet \
//!     > hooks-sdk/src/generated.rs

#[cfg(feature = "hooks-schema")]
use std::collections::BTreeSet;
#[cfg(feature = "hooks-schema")]
use std::fmt::Write;

#[cfg(feature = "hooks-schema")]
use codex_core::hooks::HookPayload;
#[cfg(feature = "hooks-schema")]
use schemars::schema_for;
#[cfg(feature = "hooks-schema")]
use serde_json::Value;

#[cfg(not(feature = "hooks-schema"))]
fn main() {
    eprintln!("error: build with `--features hooks-schema` to enable schema/type generation");
    std::process::exit(2);
}

#[cfg(feature = "hooks-schema")]
fn main() {
    let schema = schema_for!(HookPayload);
    let schema_json = match serde_json::to_value(&schema) {
        Ok(value) => value,
        Err(err) => {
            eprintln!("error: failed to serialize schema: {err}");
            std::process::exit(1);
        }
    };

    match generate_rust_sdk(&schema_json) {
        Ok(out) => print!("{out}"),
        Err(err) => {
            eprintln!("error: failed to generate Rust SDK types: {err}");
            std::process::exit(1);
        }
    }
}

#[cfg(feature = "hooks-schema")]
fn generate_rust_sdk(schema: &Value) -> Result<String, String> {
    let properties = schema
        .get("properties")
        .and_then(Value::as_object)
        .ok_or("expected top-level properties object")?;

    let required: BTreeSet<String> = schema
        .get("required")
        .and_then(Value::as_array)
        .map(|arr| {
            arr.iter()
                .filter_map(Value::as_str)
                .map(str::to_string)
                .collect()
        })
        .unwrap_or_default();

    let mut out = String::new();
    out.push_str(
        r#"// Code generated by `codex-core/src/bin/hooks_rust_sdk.rs`. DO NOT EDIT.
//
// This module is generated from the Rust hook payload schema (source-of-truth).
//
// Re-generate from the repo:
//   cd codex-rs
//   cargo run -p codex-core --bin hooks_rust_sdk --features hooks-schema --quiet \
//     > hooks-sdk/src/generated.rs

use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::BTreeMap;

pub type ExtraFields = BTreeMap<String, Value>;

"#,
    );

    writeln!(
        &mut out,
        "#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]"
    )
    .map_err(|_| "formatting failed".to_string())?;
    writeln!(&mut out, "pub struct HookPayload {{").map_err(|_| "formatting failed".to_string())?;

    let mut keys: Vec<(&String, &Value)> = properties.iter().collect();
    keys.sort_by(|(a, _), (b, _)| a.as_str().cmp(b.as_str()));
    for (key, prop_schema) in keys {
        let field_name = snake_case(key);
        let mut rust_ty = rust_type_for_schema(prop_schema);

        let is_required = required.contains(key.as_str());
        let is_nullable = schema_allows_null(prop_schema);
        if (!is_required || is_nullable) && !rust_ty.starts_with("Option<") {
            rust_ty = format!("Option<{rust_ty}>");
        }

        writeln!(&mut out, "    #[serde(rename = \"{key}\")]")
            .map_err(|_| "formatting failed".to_string())?;
        writeln!(&mut out, "    pub {field_name}: {rust_ty},")
            .map_err(|_| "formatting failed".to_string())?;
    }

    out.push_str("    #[serde(flatten)]\n");
    out.push_str("    pub extra: ExtraFields,\n");
    out.push_str("}\n");

    Ok(out)
}

#[cfg(feature = "hooks-schema")]
fn schema_allows_null(schema: &Value) -> bool {
    if schema.get("type").and_then(Value::as_str) == Some("null") {
        return true;
    }
    if let Some(arr) = schema.get("type").and_then(Value::as_array) {
        return arr.iter().any(|v| v.as_str() == Some("null"));
    }
    if let Some(one_of) = schema.get("oneOf").and_then(Value::as_array) {
        return one_of.iter().any(schema_allows_null);
    }
    false
}

#[cfg(feature = "hooks-schema")]
fn rust_type_for_schema(schema: &Value) -> String {
    if schema.get("$ref").is_some() {
        return "Value".to_string();
    }

    if let Some(ty) = schema.get("type") {
        if let Some(s) = ty.as_str() {
            return rust_type_for_primitive(s, schema);
        }
        if let Some(arr) = ty.as_array() {
            let mut types: Vec<String> = arr
                .iter()
                .filter_map(Value::as_str)
                .filter(|t| *t != "null")
                .map(|t| rust_type_for_primitive(t, schema))
                .collect();
            types.sort();
            types.dedup();
            return types
                .first()
                .cloned()
                .unwrap_or_else(|| "Value".to_string());
        }
    }

    if schema.get("oneOf").is_some() {
        return "Value".to_string();
    }

    "Value".to_string()
}

#[cfg(feature = "hooks-schema")]
fn rust_type_for_primitive(ty: &str, schema: &Value) -> String {
    match ty {
        "string" => "String".to_string(),
        "integer" => "u64".to_string(),
        "number" => "f64".to_string(),
        "boolean" => "bool".to_string(),
        "array" => {
            let item_ty = schema
                .get("items")
                .map(rust_type_for_schema)
                .unwrap_or_else(|| "Value".to_string());
            format!("Vec<{item_ty}>")
        }
        "object" => "Value".to_string(),
        _ => "Value".to_string(),
    }
}

#[cfg(feature = "hooks-schema")]
fn snake_case(input: &str) -> String {
    let mut out = String::with_capacity(input.len());
    for c in input.chars() {
        if c == '-' {
            out.push('_');
        } else {
            out.push(c);
        }
    }
    out
}
