//! Generate Go types for xcodex external hook payloads.
//!
//! Usage:
//!   cd codex-rs
//!   cargo run -p codex-core --bin hooks_go_types --features hooks-schema --quiet \
//!     > common/src/hooks_sdk_assets/go/hooksdk/types.go

#[cfg(feature = "hooks-schema")]
use std::collections::BTreeSet;
#[cfg(feature = "hooks-schema")]
use std::fmt::Write;

#[cfg(feature = "hooks-schema")]
use codex_core::hooks::HookPayload;
#[cfg(feature = "hooks-schema")]
use schemars::schema_for;
#[cfg(feature = "hooks-schema")]
use serde_json::Value;

#[cfg(not(feature = "hooks-schema"))]
fn main() {
    eprintln!("error: build with `--features hooks-schema` to enable schema/type generation");
    std::process::exit(2);
}

#[cfg(feature = "hooks-schema")]
fn main() {
    let schema = schema_for!(HookPayload);
    let schema_json = match serde_json::to_value(&schema) {
        Ok(value) => value,
        Err(err) => {
            eprintln!("error: failed to serialize schema: {err}");
            std::process::exit(1);
        }
    };

    match generate_go_types(&schema_json) {
        Ok(out) => print!("{out}"),
        Err(err) => {
            eprintln!("error: failed to generate Go types: {err}");
            std::process::exit(1);
        }
    }
}

#[cfg(feature = "hooks-schema")]
fn generate_go_types(schema: &Value) -> Result<String, String> {
    let properties = schema
        .get("properties")
        .and_then(Value::as_object)
        .ok_or("expected top-level properties object")?;

    let required: BTreeSet<String> = schema
        .get("required")
        .and_then(Value::as_array)
        .map(|arr| {
            arr.iter()
                .filter_map(Value::as_str)
                .map(str::to_string)
                .collect()
        })
        .unwrap_or_default();

    let mut out = String::new();
    out.push_str(
        r#"// Code generated by `codex-core/src/bin/hooks_go_types.rs`. DO NOT EDIT.
//
// xCodex hooks kit: Go typed helpers for external hooks.
//
// This file is installed under `$CODEX_HOME/hooks/templates/go/` by:
//   xcodex hooks install sdks go
//
// Re-generate from the repo:
//   cd codex-rs
//   cargo run -p codex-core --bin hooks_go_types --features hooks-schema --quiet \
//     > common/src/hooks_sdk_assets/go/hooksdk/types.go
package hooksdk

import (
	"encoding/json"
)

// HookPayload models the JSON payload shape emitted by xcodex hooks.
// Unknown fields are preserved in RawPayload for forward compatibility.
type HookPayload struct {
	RawPayload map[string]any `json:"-"`
"#,
    );

    let mut keys: Vec<(&String, &Value)> = properties.iter().collect();
    keys.sort_by(|(a, _), (b, _)| a.as_str().cmp(b.as_str()));
    for (key, prop_schema) in keys {
        let field_name = go_field_name(key);
        let mut go_ty = go_type_for_schema(prop_schema);

        let is_required = required.contains(key.as_str());
        let is_nullable = schema_allows_null(prop_schema);
        if (!is_required || is_nullable)
            && !go_ty.starts_with("[]")
            && !go_ty.starts_with("map[")
            && go_ty != "any"
            && !go_ty.starts_with('*')
        {
            go_ty = format!("*{go_ty}");
        }

        writeln!(&mut out, "\t{field_name} {go_ty} `json:\"{key}\"`")
            .map_err(|_| "formatting failed".to_string())?;
    }

    out.push_str(
        r#"}

func (p *HookPayload) UnmarshalJSON(data []byte) error {
	var raw map[string]any
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	type Alias HookPayload
	var a Alias
	if err := json.Unmarshal(data, &a); err != nil {
		return err
	}

	*p = HookPayload(a)
	p.RawPayload = raw
	return nil
}

// ParseHookPayload parses a hook JSON payload into a HookPayload.
func ParseHookPayload(data []byte) (*HookPayload, error) {
	var p HookPayload
	if err := json.Unmarshal(data, &p); err != nil {
		return nil, err
	}
	return &p, nil
}
"#,
    );

    Ok(out)
}

#[cfg(feature = "hooks-schema")]
fn go_field_name(key: &str) -> String {
    key.split('_')
        .filter(|part| !part.is_empty())
        .map(|part| {
            let mut chars = part.chars();
            match chars.next() {
                Some(first) => format!("{}{}", first.to_ascii_uppercase(), chars.as_str()),
                None => String::new(),
            }
        })
        .collect()
}

#[cfg(feature = "hooks-schema")]
fn schema_allows_null(schema: &Value) -> bool {
    if schema.get("type").and_then(Value::as_str) == Some("null") {
        return true;
    }
    if let Some(arr) = schema.get("type").and_then(Value::as_array) {
        return arr.iter().any(|v| v.as_str() == Some("null"));
    }
    if let Some(one_of) = schema.get("oneOf").and_then(Value::as_array) {
        return one_of.iter().any(schema_allows_null);
    }
    false
}

#[cfg(feature = "hooks-schema")]
fn go_type_for_schema(schema: &Value) -> String {
    if schema.get("$ref").is_some() {
        return "any".to_string();
    }

    if let Some(ty) = schema.get("type") {
        if let Some(s) = ty.as_str() {
            return go_type_for_primitive(s, schema);
        }
        if let Some(arr) = ty.as_array() {
            let mut types: Vec<String> = arr
                .iter()
                .filter_map(Value::as_str)
                .filter(|t| *t != "null")
                .map(|t| go_type_for_primitive(t, schema))
                .collect();
            types.sort();
            types.dedup();
            return types.first().cloned().unwrap_or_else(|| "any".to_string());
        }
    }

    if let Some(one_of) = schema.get("oneOf").and_then(Value::as_array) {
        let mut types: Vec<String> = one_of
            .iter()
            .filter(|s| !schema_allows_null(s))
            .map(go_type_for_schema)
            .collect();
        types.sort();
        types.dedup();
        return types.first().cloned().unwrap_or_else(|| "any".to_string());
    }

    "any".to_string()
}

#[cfg(feature = "hooks-schema")]
fn go_type_for_primitive(ty: &str, schema: &Value) -> String {
    match ty {
        "string" => "string".to_string(),
        "integer" | "number" => "int".to_string(),
        "boolean" => "bool".to_string(),
        "array" => {
            let item_ty = schema
                .get("items")
                .map(go_type_for_schema)
                .unwrap_or_else(|| "any".to_string());
            format!("[]{item_ty}")
        }
        "object" => "map[string]any".to_string(),
        _ => "any".to_string(),
    }
}
